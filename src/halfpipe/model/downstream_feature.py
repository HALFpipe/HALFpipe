# -*- coding: utf-8 -*-
# emacs: -*- mode: python; py-indent-offset: 4; indent-tabs-mode: nil -*-
# vi: set ft=python sts=4 ts=4 sw=4 et:

from marshmallow import Schema, fields, post_dump, post_load, validate
from marshmallow_oneofschema import OneOfSchema

# Following HALFpipe format, creating new class for downstream features that will connect to output from feature workflows
# TODO I would refactor this into subclasses that do a traits check when created


class DownstreamFeature:
    def __init__(self, name, type: str, **kwargs) -> None:
        self.name = name
        self.type = type

        for k, v in kwargs.items():
            setattr(self, k, v)

    def __hash__(self):
        return hash(self.name)  # name is unique


class BaseDownstreamFeatureSchema(Schema):
    # how is a name different than type?
    name = fields.Str()

    @post_load
    def make_object(self, data, **_):
        return DownstreamFeature(**data)

    @post_dump(pass_many=False)
    def remove_none(self, data, many):
        assert many is False
        return {key: value for key, value in data.items() if value is not None}


class GradientsDownstreamFeatureSchema(BaseDownstreamFeatureSchema):
    type = fields.Str(
        dump_default="gradients",
        validate=validate.Equal("gradients"),
    )
    # what goes here?
    # seems unnecessary bc all the defaults are assigned in the input spec
    # Need to be defined here bc it interacts w UI and user overwriting of things im not sure for now
    # TODO cut these down/consider necessary
    # TODO fix
    n_components = fields.Int(dump_default=10, allow_none=True)
    approach = fields.Str(dump_default="dm", allow_none=True)
    kernel = fields.Str(dump_default=None, allow_none=True)
    random_state = fields.Int(dump_default=None, allow_none=True)
    alignment = fields.Str(dump_default=None, allow_none=True)

    # .fit params (no x bc generated by halfpipe and will come from prev node)
    gamma = fields.Float(dump_default=None, allow_none=True)
    sparsity = fields.Float(dump_default=0.9, allow_none=True)
    n_iter = fields.Int(dump_default=10, allow_none=True)
    reference = fields.Str(dump_default=None, allow_none=True)  # would actually be a File but could be str path


class DownstreamFeatureSchema(OneOfSchema):
    type_field = "type"
    type_field_remove = False
    type_schemas = {
        "gradients": GradientsDownstreamFeatureSchema,
    }

    def get_obj_type(self, obj):
        if isinstance(obj, DownstreamFeature):
            return obj.type
        raise Exception(f"Cannot get type for {obj}")
